// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_FlxBitmapDataUtil
#include <flixel/util/FlxBitmapDataUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxRect
#include <flixel/util/FlxPool_flixel_math_FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_33_merge,"flixel.util.FlxBitmapDataUtil","merge",0x21db12bd,"flixel.util.FlxBitmapDataUtil.merge","flixel/util/FlxBitmapDataUtil.hx",33,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_154_mergeColorComponent,"flixel.util.FlxBitmapDataUtil","mergeColorComponent",0x5b71b277,"flixel.util.FlxBitmapDataUtil.mergeColorComponent","flixel/util/FlxBitmapDataUtil.hx",154,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_169_compare,"flixel.util.FlxBitmapDataUtil","compare",0x217d53ea,"flixel.util.FlxBitmapDataUtil.compare","flixel/util/FlxBitmapDataUtil.hx",169,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_233_getDiff,"flixel.util.FlxBitmapDataUtil","getDiff",0xb3004700,"flixel.util.FlxBitmapDataUtil.getDiff","flixel/util/FlxBitmapDataUtil.hx",233,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_243_getMemorySize,"flixel.util.FlxBitmapDataUtil","getMemorySize",0x5bc2859d,"flixel.util.FlxBitmapDataUtil.getMemorySize","flixel/util/FlxBitmapDataUtil.hx",243,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_258_replaceColor,"flixel.util.FlxBitmapDataUtil","replaceColor",0xbc41272a,"flixel.util.FlxBitmapDataUtil.replaceColor","flixel/util/FlxBitmapDataUtil.hx",258,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_327_addSpacesAndBorders,"flixel.util.FlxBitmapDataUtil","addSpacesAndBorders",0xf8f1a643,"flixel.util.FlxBitmapDataUtil.addSpacesAndBorders","flixel/util/FlxBitmapDataUtil.hx",327,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_408_copyBorderPixels,"flixel.util.FlxBitmapDataUtil","copyBorderPixels",0x739e20a9,"flixel.util.FlxBitmapDataUtil.copyBorderPixels","flixel/util/FlxBitmapDataUtil.hx",408,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_468_generateRotations,"flixel.util.FlxBitmapDataUtil","generateRotations",0xe085af05,"flixel.util.FlxBitmapDataUtil.generateRotations","flixel/util/FlxBitmapDataUtil.hx",468,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_17_boot,"flixel.util.FlxBitmapDataUtil","boot",0x2db7bbcd,"flixel.util.FlxBitmapDataUtil.boot","flixel/util/FlxBitmapDataUtil.hx",17,0xf477b24b)
namespace flixel{
namespace util{

void FlxBitmapDataUtil_obj::__construct() { }

Dynamic FlxBitmapDataUtil_obj::__CreateEmpty() { return new FlxBitmapDataUtil_obj; }

void *FlxBitmapDataUtil_obj::_hx_vtable = 0;

Dynamic FlxBitmapDataUtil_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxBitmapDataUtil_obj > _hx_result = new FlxBitmapDataUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxBitmapDataUtil_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1b702c2f;
}

 ::flixel::math::FlxMatrix FlxBitmapDataUtil_obj::matrix;

void FlxBitmapDataUtil_obj::merge( ::openfl::display::BitmapData sourceBitmapData, ::openfl::geom::Rectangle sourceRect, ::openfl::display::BitmapData destBitmapData, ::openfl::geom::Point destPoint,int redMultiplier,int greenMultiplier,int blueMultiplier,int alphaMultiplier){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_33_merge)
HXLINE(  37)		bool _hx_tmp;
HXDLIN(  37)		bool _hx_tmp1;
HXDLIN(  37)		bool _hx_tmp2;
HXDLIN(  37)		bool _hx_tmp3;
HXDLIN(  37)		bool _hx_tmp4;
HXDLIN(  37)		if (!((destPoint->x >= destBitmapData->width))) {
HXLINE(  37)			_hx_tmp4 = (destPoint->y >= destBitmapData->height);
            		}
            		else {
HXLINE(  37)			_hx_tmp4 = true;
            		}
HXDLIN(  37)		if (!(_hx_tmp4)) {
HXLINE(  37)			_hx_tmp3 = (sourceRect->x >= sourceBitmapData->width);
            		}
            		else {
HXLINE(  37)			_hx_tmp3 = true;
            		}
HXDLIN(  37)		if (!(_hx_tmp3)) {
HXLINE(  37)			_hx_tmp2 = (sourceRect->y >= sourceBitmapData->height);
            		}
            		else {
HXLINE(  37)			_hx_tmp2 = true;
            		}
HXDLIN(  37)		if (!(_hx_tmp2)) {
HXLINE(  37)			_hx_tmp1 = ((sourceRect->x + sourceRect->width) <= (int)0);
            		}
            		else {
HXLINE(  37)			_hx_tmp1 = true;
            		}
HXDLIN(  37)		if (!(_hx_tmp1)) {
HXLINE(  37)			_hx_tmp = ((sourceRect->y + sourceRect->height) <= (int)0);
            		}
            		else {
HXLINE(  37)			_hx_tmp = true;
            		}
HXDLIN(  37)		if (_hx_tmp) {
HXLINE(  44)			return;
            		}
HXLINE(  48)		while(true){
HXLINE(  48)			bool _hx_tmp5;
HXDLIN(  48)			bool _hx_tmp6;
HXDLIN(  48)			bool _hx_tmp7;
HXDLIN(  48)			bool _hx_tmp8;
HXDLIN(  48)			bool _hx_tmp9;
HXDLIN(  48)			if (!(((sourceRect->x + sourceRect->width) > sourceBitmapData->width))) {
HXLINE(  48)				_hx_tmp9 = ((sourceRect->y + sourceRect->height) > sourceBitmapData->height);
            			}
            			else {
HXLINE(  48)				_hx_tmp9 = true;
            			}
HXDLIN(  48)			if (!(_hx_tmp9)) {
HXLINE(  48)				_hx_tmp8 = (sourceRect->x < (int)0);
            			}
            			else {
HXLINE(  48)				_hx_tmp8 = true;
            			}
HXDLIN(  48)			if (!(_hx_tmp8)) {
HXLINE(  48)				_hx_tmp7 = (sourceRect->y < (int)0);
            			}
            			else {
HXLINE(  48)				_hx_tmp7 = true;
            			}
HXDLIN(  48)			if (!(_hx_tmp7)) {
HXLINE(  48)				_hx_tmp6 = (destPoint->x < (int)0);
            			}
            			else {
HXLINE(  48)				_hx_tmp6 = true;
            			}
HXDLIN(  48)			if (!(_hx_tmp6)) {
HXLINE(  48)				_hx_tmp5 = (destPoint->y < (int)0);
            			}
            			else {
HXLINE(  48)				_hx_tmp5 = true;
            			}
HXDLIN(  48)			if (!(_hx_tmp5)) {
HXLINE(  48)				goto _hx_goto_0;
            			}
HXLINE(  55)			if (((sourceRect->x + sourceRect->width) > sourceBitmapData->width)) {
HXLINE(  56)				sourceRect->width = (sourceBitmapData->width - sourceRect->x);
            			}
HXLINE(  57)			if (((sourceRect->y + sourceRect->height) > sourceBitmapData->height)) {
HXLINE(  58)				sourceRect->height = (sourceBitmapData->height - sourceRect->y);
            			}
HXLINE(  60)			if ((sourceRect->x < (int)0)) {
HXLINE(  62)				destPoint->x = (destPoint->x - sourceRect->x);
HXLINE(  63)				sourceRect->width = (sourceRect->width + sourceRect->x);
HXLINE(  64)				sourceRect->x = (int)0;
            			}
HXLINE(  67)			if ((sourceRect->y < (int)0)) {
HXLINE(  69)				destPoint->y = (destPoint->y - sourceRect->y);
HXLINE(  70)				sourceRect->height = (sourceRect->height + sourceRect->y);
HXLINE(  71)				sourceRect->y = (int)0;
            			}
HXLINE(  74)			bool _hx_tmp10;
HXDLIN(  74)			if (!((destPoint->x >= destBitmapData->width))) {
HXLINE(  74)				_hx_tmp10 = (destPoint->y >= destBitmapData->height);
            			}
            			else {
HXLINE(  74)				_hx_tmp10 = true;
            			}
HXDLIN(  74)			if (_hx_tmp10) {
HXLINE(  75)				return;
            			}
HXLINE(  77)			if ((destPoint->x < (int)0)) {
HXLINE(  79)				sourceRect->x = (sourceRect->x - destPoint->x);
HXLINE(  80)				sourceRect->width = (sourceRect->width + destPoint->x);
HXLINE(  81)				destPoint->x = (int)0;
            			}
HXLINE(  84)			if ((destPoint->y < (int)0)) {
HXLINE(  86)				sourceRect->y = (sourceRect->y - destPoint->y);
HXLINE(  87)				sourceRect->height = (sourceRect->height + destPoint->y);
HXLINE(  88)				destPoint->y = (int)0;
            			}
            		}
            		_hx_goto_0:;
HXLINE(  92)		bool _hx_tmp11;
HXDLIN(  92)		if (!((sourceRect->width <= (int)0))) {
HXLINE(  92)			_hx_tmp11 = (sourceRect->height <= (int)0);
            		}
            		else {
HXLINE(  92)			_hx_tmp11 = true;
            		}
HXDLIN(  92)		if (_hx_tmp11) {
HXLINE(  93)			return;
            		}
HXLINE(  95)		int startSourceX = ::Math_obj::round(sourceRect->x);
HXLINE(  96)		int startSourceY = ::Math_obj::round(sourceRect->y);
HXLINE(  98)		int width = ::Math_obj::round(sourceRect->width);
HXLINE(  99)		int height = ::Math_obj::round(sourceRect->height);
HXLINE( 101)		int sourceX = startSourceX;
HXLINE( 102)		int sourceY = startSourceY;
HXLINE( 104)		int destX = ::Math_obj::round(destPoint->x);
HXLINE( 105)		int destY = ::Math_obj::round(destPoint->y);
HXLINE( 107)		int currX = destX;
HXLINE( 108)		int currY = destY;
HXLINE( 110)		int sourceColor;
HXLINE( 111)		int destColor;
HXLINE( 113)		int resultRed;
HXLINE( 114)		int resultGreen;
HXLINE( 115)		int resultBlue;
HXLINE( 116)		int resultAlpha;
HXLINE( 118)		int resultColor = (int)0;
HXLINE( 119)		destBitmapData->lock();
HXLINE( 122)		{
HXLINE( 122)			int _g1 = (int)0;
HXDLIN( 122)			int _g = width;
HXDLIN( 122)			while((_g1 < _g)){
HXLINE( 122)				_g1 = (_g1 + (int)1);
HXDLIN( 122)				int i = (_g1 - (int)1);
HXLINE( 124)				{
HXLINE( 124)					int _g3 = (int)0;
HXDLIN( 124)					int _g2 = height;
HXDLIN( 124)					while((_g3 < _g2)){
HXLINE( 124)						_g3 = (_g3 + (int)1);
HXDLIN( 124)						int j = (_g3 - (int)1);
HXLINE( 126)						sourceX = (startSourceX + i);
HXLINE( 127)						sourceY = (startSourceY + j);
HXLINE( 129)						currX = (destX + i);
HXLINE( 130)						currY = (destY + j);
HXLINE( 132)						sourceColor = sourceBitmapData->getPixel32(sourceX,sourceY);
HXLINE( 133)						destColor = destBitmapData->getPixel32(currX,currY);
HXLINE( 136)						resultRed = ::Std_obj::_hx_int(((Float)((((int)((int)sourceColor >> (int)(int)16) & (int)(int)255) * redMultiplier) + (((int)((int)destColor >> (int)(int)16) & (int)(int)255) * ((int)256 - redMultiplier))) / (Float)(int)256));
HXLINE( 137)						resultGreen = ::Std_obj::_hx_int(((Float)((((int)((int)sourceColor >> (int)(int)8) & (int)(int)255) * greenMultiplier) + (((int)((int)destColor >> (int)(int)8) & (int)(int)255) * ((int)256 - greenMultiplier))) / (Float)(int)256));
HXLINE( 138)						resultBlue = ::Std_obj::_hx_int(((Float)((((int)sourceColor & (int)(int)255) * blueMultiplier) + (((int)destColor & (int)(int)255) * ((int)256 - blueMultiplier))) / (Float)(int)256));
HXLINE( 139)						resultAlpha = ::Std_obj::_hx_int(((Float)((((int)((int)sourceColor >> (int)(int)24) & (int)(int)255) * alphaMultiplier) + (((int)((int)destColor >> (int)(int)24) & (int)(int)255) * ((int)256 - alphaMultiplier))) / (Float)(int)256));
HXLINE( 142)						int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 142)						{
HXLINE( 142)							color = ((int)color & (int)(int)-16711681);
HXDLIN( 142)							int color1;
HXDLIN( 142)							if ((resultRed > (int)255)) {
HXLINE( 142)								color1 = (int)255;
            							}
            							else {
HXLINE( 142)								if ((resultRed < (int)0)) {
HXLINE( 142)									color1 = (int)0;
            								}
            								else {
HXLINE( 142)									color1 = resultRed;
            								}
            							}
HXDLIN( 142)							color = ((int)color | (int)((int)color1 << (int)(int)16));
            						}
HXDLIN( 142)						{
HXLINE( 142)							color = ((int)color & (int)(int)-65281);
HXDLIN( 142)							int color2;
HXDLIN( 142)							if ((resultGreen > (int)255)) {
HXLINE( 142)								color2 = (int)255;
            							}
            							else {
HXLINE( 142)								if ((resultGreen < (int)0)) {
HXLINE( 142)									color2 = (int)0;
            								}
            								else {
HXLINE( 142)									color2 = resultGreen;
            								}
            							}
HXDLIN( 142)							color = ((int)color | (int)((int)color2 << (int)(int)8));
            						}
HXDLIN( 142)						{
HXLINE( 142)							color = ((int)color & (int)(int)-256);
HXDLIN( 142)							int color3;
HXDLIN( 142)							if ((resultBlue > (int)255)) {
HXLINE( 142)								color3 = (int)255;
            							}
            							else {
HXLINE( 142)								if ((resultBlue < (int)0)) {
HXLINE( 142)									color3 = (int)0;
            								}
            								else {
HXLINE( 142)									color3 = resultBlue;
            								}
            							}
HXDLIN( 142)							color = ((int)color | (int)color3);
            						}
HXDLIN( 142)						{
HXLINE( 142)							color = ((int)color & (int)(int)16777215);
HXDLIN( 142)							int color4;
HXDLIN( 142)							if ((resultAlpha > (int)255)) {
HXLINE( 142)								color4 = (int)255;
            							}
            							else {
HXLINE( 142)								if ((resultAlpha < (int)0)) {
HXLINE( 142)									color4 = (int)0;
            								}
            								else {
HXLINE( 142)									color4 = resultAlpha;
            								}
            							}
HXDLIN( 142)							color = ((int)color | (int)((int)color4 << (int)(int)24));
            						}
HXDLIN( 142)						resultColor = color;
HXLINE( 145)						destBitmapData->setPixel32(currX,currY,resultColor);
            					}
            				}
            			}
            		}
HXLINE( 148)		destBitmapData->unlock(null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(FlxBitmapDataUtil_obj,merge,(void))

int FlxBitmapDataUtil_obj::mergeColorComponent(int source,int dest,int multiplier){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_154_mergeColorComponent)
HXDLIN( 154)		return ::Std_obj::_hx_int(((Float)((source * multiplier) + (dest * ((int)256 - multiplier))) / (Float)(int)256));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxBitmapDataUtil_obj,mergeColorComponent,return )

 ::Dynamic FlxBitmapDataUtil_obj::compare( ::openfl::display::BitmapData Bitmap1, ::openfl::display::BitmapData Bitmap2){
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_169_compare)
HXLINE( 173)		if (hx::IsEq( Bitmap1,Bitmap2 )) {
HXLINE( 175)			return (int)0;
            		}
HXLINE( 177)		if ((Bitmap1->width != Bitmap2->width)) {
HXLINE( 179)			return (int)-3;
            		}
            		else {
HXLINE( 181)			if ((Bitmap1->height != Bitmap2->height)) {
HXLINE( 183)				return (int)-4;
            			}
            			else {
HXLINE( 187)				int width = Bitmap1->width;
HXLINE( 188)				int height = Bitmap1->height;
HXLINE( 189)				 ::openfl::display::BitmapData result =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,width,height,true,(int)0);
HXLINE( 190)				bool identical = true;
HXLINE( 192)				{
HXLINE( 192)					int _g1 = (int)0;
HXDLIN( 192)					int _g = width;
HXDLIN( 192)					while((_g1 < _g)){
HXLINE( 192)						_g1 = (_g1 + (int)1);
HXDLIN( 192)						int i = (_g1 - (int)1);
HXLINE( 194)						{
HXLINE( 194)							int _g3 = (int)0;
HXDLIN( 194)							int _g2 = height;
HXDLIN( 194)							while((_g3 < _g2)){
HXLINE( 194)								_g3 = (_g3 + (int)1);
HXDLIN( 194)								int j = (_g3 - (int)1);
HXLINE( 196)								int pixel1 = Bitmap1->getPixel32(i,j);
HXLINE( 197)								int pixel2 = Bitmap2->getPixel32(i,j);
HXLINE( 199)								if ((pixel1 != pixel2)) {
HXLINE( 201)									identical = false;
HXLINE( 203)									if ((((int)pixel1 & (int)(int)16777215) != ((int)pixel2 & (int)(int)16777215))) {
HXLINE( 206)										int diff = (((int)((int)pixel1 >> (int)(int)16) & (int)(int)255) - ((int)((int)pixel2 >> (int)(int)16) & (int)(int)255));
HXDLIN( 206)										int Red;
HXDLIN( 206)										if ((diff >= (int)0)) {
HXLINE( 206)											Red = diff;
            										}
            										else {
HXLINE( 206)											Red = ((int)256 + diff);
            										}
HXDLIN( 206)										int diff1 = (((int)((int)pixel1 >> (int)(int)8) & (int)(int)255) - ((int)((int)pixel2 >> (int)(int)8) & (int)(int)255));
HXDLIN( 206)										int Green;
HXDLIN( 206)										if ((diff1 >= (int)0)) {
HXLINE( 206)											Green = diff1;
            										}
            										else {
HXLINE( 206)											Green = ((int)256 + diff1);
            										}
HXDLIN( 206)										int diff2 = (((int)pixel1 & (int)(int)255) - ((int)pixel2 & (int)(int)255));
HXDLIN( 206)										int Blue;
HXDLIN( 206)										if ((diff2 >= (int)0)) {
HXLINE( 206)											Blue = diff2;
            										}
            										else {
HXLINE( 206)											Blue = ((int)256 + diff2);
            										}
HXDLIN( 206)										int Alpha = (int)255;
HXDLIN( 206)										int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 206)										{
HXLINE( 206)											color = ((int)color & (int)(int)-16711681);
HXDLIN( 206)											int color1;
HXDLIN( 206)											if ((Red > (int)255)) {
HXLINE( 206)												color1 = (int)255;
            											}
            											else {
HXLINE( 206)												if ((Red < (int)0)) {
HXLINE( 206)													color1 = (int)0;
            												}
            												else {
HXLINE( 206)													color1 = Red;
            												}
            											}
HXDLIN( 206)											color = ((int)color | (int)((int)color1 << (int)(int)16));
            										}
HXDLIN( 206)										{
HXLINE( 206)											color = ((int)color & (int)(int)-65281);
HXDLIN( 206)											int color2;
HXDLIN( 206)											if ((Green > (int)255)) {
HXLINE( 206)												color2 = (int)255;
            											}
            											else {
HXLINE( 206)												if ((Green < (int)0)) {
HXLINE( 206)													color2 = (int)0;
            												}
            												else {
HXLINE( 206)													color2 = Green;
            												}
            											}
HXDLIN( 206)											color = ((int)color | (int)((int)color2 << (int)(int)8));
            										}
HXDLIN( 206)										{
HXLINE( 206)											color = ((int)color & (int)(int)-256);
HXDLIN( 206)											int color3;
HXDLIN( 206)											if ((Blue > (int)255)) {
HXLINE( 206)												color3 = (int)255;
            											}
            											else {
HXLINE( 206)												if ((Blue < (int)0)) {
HXLINE( 206)													color3 = (int)0;
            												}
            												else {
HXLINE( 206)													color3 = Blue;
            												}
            											}
HXDLIN( 206)											color = ((int)color | (int)color3);
            										}
HXDLIN( 206)										{
HXLINE( 206)											color = ((int)color & (int)(int)16777215);
HXDLIN( 206)											int color4;
HXDLIN( 206)											if ((Alpha > (int)255)) {
HXLINE( 206)												color4 = (int)255;
            											}
            											else {
HXLINE( 206)												if ((Alpha < (int)0)) {
HXLINE( 206)													color4 = (int)0;
            												}
            												else {
HXLINE( 206)													color4 = Alpha;
            												}
            											}
HXDLIN( 206)											color = ((int)color | (int)((int)color4 << (int)(int)24));
            										}
HXLINE( 205)										result->setPixel32(i,j,color);
            									}
            									else {
HXLINE( 210)										int alpha1 = ((int)((int)pixel1 >> (int)(int)24) & (int)(int)255);
HXLINE( 211)										int alpha2 = ((int)((int)pixel2 >> (int)(int)24) & (int)(int)255);
HXLINE( 213)										if ((alpha1 != alpha2)) {
HXLINE( 215)											int diff3 = (alpha1 - alpha2);
HXDLIN( 215)											int Alpha1;
HXDLIN( 215)											if ((diff3 >= (int)0)) {
HXLINE( 215)												Alpha1 = diff3;
            											}
            											else {
HXLINE( 215)												Alpha1 = ((int)256 + diff3);
            											}
HXDLIN( 215)											int color5 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 215)											{
HXLINE( 215)												color5 = ((int)color5 & (int)(int)-16711681);
HXDLIN( 215)												color5 = ((int)color5 | (int)(int)16711680);
            											}
HXDLIN( 215)											{
HXLINE( 215)												color5 = ((int)color5 & (int)(int)-65281);
HXDLIN( 215)												color5 = ((int)color5 | (int)(int)65280);
            											}
HXDLIN( 215)											{
HXLINE( 215)												color5 = ((int)color5 & (int)(int)-256);
HXDLIN( 215)												color5 = ((int)color5 | (int)(int)255);
            											}
HXDLIN( 215)											{
HXLINE( 215)												color5 = ((int)color5 & (int)(int)16777215);
HXDLIN( 215)												int color6;
HXDLIN( 215)												if ((Alpha1 > (int)255)) {
HXLINE( 215)													color6 = (int)255;
            												}
            												else {
HXLINE( 215)													if ((Alpha1 < (int)0)) {
HXLINE( 215)														color6 = (int)0;
            													}
            													else {
HXLINE( 215)														color6 = Alpha1;
            													}
            												}
HXDLIN( 215)												color5 = ((int)color5 | (int)((int)color6 << (int)(int)24));
            											}
HXDLIN( 215)											result->setPixel32(i,j,color5);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXLINE( 222)				if (!(identical)) {
HXLINE( 224)					return result;
            				}
            			}
            		}
HXLINE( 228)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxBitmapDataUtil_obj,compare,return )

int FlxBitmapDataUtil_obj::getDiff(int value1,int value2){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_233_getDiff)
HXLINE( 234)		int diff = (value1 - value2);
HXLINE( 235)		if ((diff >= (int)0)) {
HXLINE( 235)			return diff;
            		}
            		else {
HXLINE( 235)			return ((int)256 + diff);
            		}
HXDLIN( 235)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxBitmapDataUtil_obj,getDiff,return )

Float FlxBitmapDataUtil_obj::getMemorySize( ::openfl::display::BitmapData bitmapData){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_243_getMemorySize)
HXDLIN( 243)		return ((bitmapData->width * bitmapData->height) * (int)4);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapDataUtil_obj,getMemorySize,return )

::Array< ::Dynamic> FlxBitmapDataUtil_obj::replaceColor( ::openfl::display::BitmapData bitmapData,int color,int newColor,hx::Null< bool >  __o_fetchPositions, ::flixel::math::FlxRect rect){
bool fetchPositions = __o_fetchPositions.Default(false);
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_258_replaceColor)
HXLINE( 259)		::Array< ::Dynamic> positions = null();
HXLINE( 260)		if (fetchPositions) {
HXLINE( 262)			positions = ::Array_obj< ::Dynamic>::__new();
            		}
HXLINE( 265)		int startX = (int)0;
HXLINE( 266)		int startY = (int)0;
HXLINE( 267)		int columns = bitmapData->width;
HXLINE( 268)		int rows = bitmapData->height;
HXLINE( 270)		if (hx::IsNotNull( rect )) {
HXLINE( 272)			startX = ::Std_obj::_hx_int(rect->x);
HXLINE( 273)			startY = ::Std_obj::_hx_int(rect->y);
HXLINE( 274)			columns = ::Std_obj::_hx_int(rect->width);
HXLINE( 275)			rows = ::Std_obj::_hx_int(rect->height);
            		}
HXLINE( 278)		columns = ::Std_obj::_hx_int(::Math_obj::max(columns,bitmapData->width));
HXLINE( 279)		rows = ::Std_obj::_hx_int(::Math_obj::max(rows,bitmapData->height));
HXLINE( 281)		int row = (int)0;
HXLINE( 282)		int column = (int)0;
HXLINE( 283)		int x;
HXDLIN( 283)		int y;
HXLINE( 285)		bool changed = false;
HXLINE( 286)		bitmapData->lock();
HXLINE( 287)		while((row < rows)){
HXLINE( 289)			column = (int)0;
HXLINE( 290)			while((column < columns)){
HXLINE( 292)				x = (startX + column);
HXLINE( 293)				y = (startY + row);
HXLINE( 294)				if ((bitmapData->getPixel32(x,y) == color)) {
HXLINE( 296)					bitmapData->setPixel32(x,y,newColor);
HXLINE( 297)					changed = true;
HXLINE( 298)					if (fetchPositions) {
HXLINE( 300)						 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set(x,y);
HXDLIN( 300)						point->_inPool = false;
HXDLIN( 300)						positions->push(point);
            					}
            				}
HXLINE( 303)				column = (column + (int)1);
            			}
HXLINE( 305)			row = (row + (int)1);
            		}
HXLINE( 307)		bitmapData->unlock(null());
HXLINE( 309)		bool _hx_tmp;
HXDLIN( 309)		if (changed) {
HXLINE( 309)			_hx_tmp = hx::IsNull( positions );
            		}
            		else {
HXLINE( 309)			_hx_tmp = false;
            		}
HXDLIN( 309)		if (_hx_tmp) {
HXLINE( 311)			positions = ::Array_obj< ::Dynamic>::__new();
            		}
HXLINE( 314)		return positions;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxBitmapDataUtil_obj,replaceColor,return )

 ::openfl::display::BitmapData FlxBitmapDataUtil_obj::addSpacesAndBorders( ::openfl::display::BitmapData bitmapData, ::flixel::math::FlxPoint frameSize, ::flixel::math::FlxPoint spacing, ::flixel::math::FlxPoint border, ::flixel::math::FlxRect region){
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_327_addSpacesAndBorders)
HXLINE( 328)		if (hx::IsNull( region )) {
HXLINE( 330)			Float Width = bitmapData->width;
HXDLIN( 330)			Float Height = bitmapData->height;
HXDLIN( 330)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 330)			_this->x = (int)0;
HXDLIN( 330)			_this->y = (int)0;
HXDLIN( 330)			_this->width = Width;
HXDLIN( 330)			_this->height = Height;
HXDLIN( 330)			 ::flixel::math::FlxRect rect = _this;
HXDLIN( 330)			rect->_inPool = false;
HXDLIN( 330)			region = rect;
            		}
HXLINE( 333)		int frameWidth = ::Std_obj::_hx_int(region->width);
HXLINE( 334)		int frameHeight = ::Std_obj::_hx_int(region->height);
HXLINE( 336)		if (hx::IsNotNull( frameSize )) {
HXLINE( 338)			frameWidth = ::Std_obj::_hx_int(frameSize->x);
HXLINE( 339)			frameHeight = ::Std_obj::_hx_int(frameSize->y);
            		}
HXLINE( 342)		int numHorizontalFrames = ::Std_obj::_hx_int(((Float)region->width / (Float)frameWidth));
HXLINE( 343)		int numVerticalFrames = ::Std_obj::_hx_int(((Float)region->height / (Float)frameHeight));
HXLINE( 345)		int spaceX = (int)0;
HXLINE( 346)		int spaceY = (int)0;
HXLINE( 348)		if (hx::IsNotNull( spacing )) {
HXLINE( 350)			spaceX = ::Std_obj::_hx_int(spacing->x);
HXLINE( 351)			spaceY = ::Std_obj::_hx_int(spacing->y);
            		}
HXLINE( 354)		int borderX = (int)0;
HXLINE( 355)		int borderY = (int)0;
HXLINE( 357)		if (hx::IsNotNull( border )) {
HXLINE( 359)			borderX = ::Std_obj::_hx_int(border->x);
HXLINE( 360)			borderY = ::Std_obj::_hx_int(border->y);
            		}
HXLINE( 363)		Float region1 = region->width;
HXDLIN( 363)		Float result = (region1 + ((numHorizontalFrames - (int)1) * spaceX));
HXDLIN( 363)		int result1 = ::Std_obj::_hx_int((result + (((int)2 * numHorizontalFrames) * borderX)));
HXLINE( 364)		Float region2 = region->height;
HXDLIN( 364)		Float result2 = (region2 + ((numVerticalFrames - (int)1) * spaceY));
HXLINE( 363)		 ::openfl::display::BitmapData result3 =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,result1,::Std_obj::_hx_int((result2 + (((int)2 * numVerticalFrames) * borderY))),true,(int)0);
HXLINE( 366)		result3->lock();
HXLINE( 367)		 ::openfl::geom::Rectangle tempRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,(int)0,(int)0,frameWidth,frameHeight);
HXLINE( 368)		 ::openfl::geom::Point tempPoint =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 371)		{
HXLINE( 371)			int _g1 = (int)0;
HXDLIN( 371)			int _g = numHorizontalFrames;
HXDLIN( 371)			while((_g1 < _g)){
HXLINE( 371)				_g1 = (_g1 + (int)1);
HXDLIN( 371)				int i = (_g1 - (int)1);
HXLINE( 373)				tempPoint->x = ((i * ((frameWidth + spaceX) + ((int)2 * borderX))) + borderX);
HXLINE( 374)				tempRect->x = ((i * frameWidth) + region->x);
HXLINE( 376)				{
HXLINE( 376)					int _g3 = (int)0;
HXDLIN( 376)					int _g2 = numVerticalFrames;
HXDLIN( 376)					while((_g3 < _g2)){
HXLINE( 376)						_g3 = (_g3 + (int)1);
HXDLIN( 376)						int j = (_g3 - (int)1);
HXLINE( 378)						tempPoint->y = ((j * ((frameHeight + spaceY) + ((int)2 * borderY))) + borderY);
HXLINE( 379)						tempRect->y = ((j * frameHeight) + region->y);
HXLINE( 380)						result3->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 383)		result3->unlock(null());
HXLINE( 386)		::flixel::util::FlxBitmapDataUtil_obj::copyBorderPixels(result3,frameWidth,frameHeight,spaceX,spaceY,borderX,borderY,numHorizontalFrames,numVerticalFrames);
HXLINE( 387)		return result3;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxBitmapDataUtil_obj,addSpacesAndBorders,return )

 ::openfl::display::BitmapData FlxBitmapDataUtil_obj::copyBorderPixels( ::openfl::display::BitmapData bitmapData,int frameWidth,int frameHeight,int spaceX,int spaceY,int borderX,int borderY,int horizontalFrames,int verticalFrames){
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_408_copyBorderPixels)
HXLINE( 410)		 ::openfl::geom::Rectangle tempRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,(int)0,(int)0,(int)1,bitmapData->height);
HXLINE( 411)		 ::openfl::geom::Point tempPoint =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 412)		bitmapData->lock();
HXLINE( 414)		{
HXLINE( 414)			int _g1 = (int)0;
HXDLIN( 414)			int _g = horizontalFrames;
HXDLIN( 414)			while((_g1 < _g)){
HXLINE( 414)				_g1 = (_g1 + (int)1);
HXDLIN( 414)				int i = (_g1 - (int)1);
HXLINE( 416)				tempRect->x = ((i * ((frameWidth + ((int)2 * borderX)) + spaceX)) + borderX);
HXLINE( 418)				{
HXLINE( 418)					int _g3 = (int)0;
HXDLIN( 418)					int _g2 = borderX;
HXDLIN( 418)					while((_g3 < _g2)){
HXLINE( 418)						_g3 = (_g3 + (int)1);
HXDLIN( 418)						int j = (_g3 - (int)1);
HXLINE( 420)						tempPoint->x = ((tempRect->x - j) - (int)1);
HXLINE( 421)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
HXLINE( 424)				 ::openfl::geom::Rectangle tempRect1 = tempRect;
HXDLIN( 424)				tempRect1->x = (tempRect1->x + (frameWidth - (int)1));
HXLINE( 426)				{
HXLINE( 426)					int _g31 = (int)0;
HXDLIN( 426)					int _g21 = borderX;
HXDLIN( 426)					while((_g31 < _g21)){
HXLINE( 426)						_g31 = (_g31 + (int)1);
HXDLIN( 426)						int j1 = (_g31 - (int)1);
HXLINE( 428)						tempPoint->x = ((tempRect->x + j1) + (int)1);
HXLINE( 429)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 433)		tempPoint->setTo((int)0,(int)0);
HXLINE( 434)		tempRect->setTo((int)0,(int)0,bitmapData->width,(int)1);
HXLINE( 435)		{
HXLINE( 435)			int _g11 = (int)0;
HXDLIN( 435)			int _g4 = verticalFrames;
HXDLIN( 435)			while((_g11 < _g4)){
HXLINE( 435)				_g11 = (_g11 + (int)1);
HXDLIN( 435)				int i1 = (_g11 - (int)1);
HXLINE( 437)				tempRect->y = ((i1 * ((frameHeight + ((int)2 * borderY)) + spaceY)) + borderY);
HXLINE( 439)				{
HXLINE( 439)					int _g32 = (int)0;
HXDLIN( 439)					int _g22 = borderY;
HXDLIN( 439)					while((_g32 < _g22)){
HXLINE( 439)						_g32 = (_g32 + (int)1);
HXDLIN( 439)						int j2 = (_g32 - (int)1);
HXLINE( 441)						tempPoint->y = ((tempRect->y - j2) - (int)1);
HXLINE( 442)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
HXLINE( 445)				 ::openfl::geom::Rectangle tempRect2 = tempRect;
HXDLIN( 445)				tempRect2->y = (tempRect2->y + (frameHeight - (int)1));
HXLINE( 447)				{
HXLINE( 447)					int _g33 = (int)0;
HXDLIN( 447)					int _g23 = borderY;
HXDLIN( 447)					while((_g33 < _g23)){
HXLINE( 447)						_g33 = (_g33 + (int)1);
HXDLIN( 447)						int j3 = (_g33 - (int)1);
HXLINE( 449)						tempPoint->y = ((tempRect->y + j3) + (int)1);
HXLINE( 450)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 454)		bitmapData->unlock(null());
HXLINE( 455)		return bitmapData;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(FlxBitmapDataUtil_obj,copyBorderPixels,return )

 ::openfl::display::BitmapData FlxBitmapDataUtil_obj::generateRotations( ::openfl::display::BitmapData brush,hx::Null< int >  __o_rotations,hx::Null< bool >  __o_antiAliasing,hx::Null< bool >  __o_autoBuffer){
int rotations = __o_rotations.Default(16);
bool antiAliasing = __o_antiAliasing.Default(false);
bool autoBuffer = __o_autoBuffer.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_468_generateRotations)
HXLINE( 469)		int brushWidth = brush->width;
HXLINE( 470)		int brushHeight = brush->height;
HXLINE( 471)		int max;
HXDLIN( 471)		if ((brushHeight > brushWidth)) {
HXLINE( 471)			max = brushHeight;
            		}
            		else {
HXLINE( 471)			max = brushWidth;
            		}
HXLINE( 472)		if (autoBuffer) {
HXLINE( 472)			max = ::Std_obj::_hx_int((max * ((Float)1.5)));
            		}
            		else {
HXLINE( 472)			max = max;
            		}
HXLINE( 474)		int rows = ::Std_obj::_hx_int(::Math_obj::sqrt(rotations));
HXLINE( 475)		int columns = ::Math_obj::ceil(((Float)rotations / (Float)rows));
HXLINE( 476)		Float bakedRotationAngle = ((Float)(int)360 / (Float)rotations);
HXLINE( 478)		int width = (max * columns);
HXLINE( 479)		int height = (max * rows);
HXLINE( 481)		 ::openfl::display::BitmapData result =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,width,height,true,(int)0);
HXLINE( 483)		int row = (int)0;
HXLINE( 484)		int column = (int)0;
HXLINE( 485)		Float bakedAngle = (int)0;
HXLINE( 486)		int halfBrushWidth = ::Std_obj::_hx_int((brushWidth * ((Float)0.5)));
HXLINE( 487)		int halfBrushHeight = ::Std_obj::_hx_int((brushHeight * ((Float)0.5)));
HXLINE( 488)		int midpointX = ::Std_obj::_hx_int((max * ((Float)0.5)));
HXLINE( 489)		int midpointY = ::Std_obj::_hx_int((max * ((Float)0.5)));
HXLINE( 491)		while((row < rows)){
HXLINE( 493)			column = (int)0;
HXLINE( 494)			while((column < columns)){
HXLINE( 496)				::flixel::util::FlxBitmapDataUtil_obj::matrix->identity();
HXLINE( 497)				::flixel::util::FlxBitmapDataUtil_obj::matrix->translate(-(halfBrushWidth),-(halfBrushHeight));
HXLINE( 498)				 ::flixel::math::FlxMatrix _hx_tmp = ::flixel::util::FlxBitmapDataUtil_obj::matrix;
HXDLIN( 498)				_hx_tmp->rotate((bakedAngle * ((Float)::Math_obj::PI / (Float)(int)180)));
HXLINE( 499)				 ::flixel::math::FlxMatrix _hx_tmp1 = ::flixel::util::FlxBitmapDataUtil_obj::matrix;
HXDLIN( 499)				_hx_tmp1->translate(((max * column) + midpointX),midpointY);
HXLINE( 500)				bakedAngle = (bakedAngle + bakedRotationAngle);
HXLINE( 501)				result->draw(brush,::flixel::util::FlxBitmapDataUtil_obj::matrix,null(),null(),null(),antiAliasing);
HXLINE( 502)				column = (column + (int)1);
            			}
HXLINE( 504)			midpointY = (midpointY + max);
HXLINE( 505)			row = (row + (int)1);
            		}
HXLINE( 508)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxBitmapDataUtil_obj,generateRotations,return )


FlxBitmapDataUtil_obj::FlxBitmapDataUtil_obj()
{
}

bool FlxBitmapDataUtil_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"merge") ) { outValue = merge_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { outValue = ( matrix ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"compare") ) { outValue = compare_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getDiff") ) { outValue = getDiff_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"replaceColor") ) { outValue = replaceColor_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getMemorySize") ) { outValue = getMemorySize_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"copyBorderPixels") ) { outValue = copyBorderPixels_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"generateRotations") ) { outValue = generateRotations_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"mergeColorComponent") ) { outValue = mergeColorComponent_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"addSpacesAndBorders") ) { outValue = addSpacesAndBorders_dyn(); return true; }
	}
	return false;
}

bool FlxBitmapDataUtil_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { matrix=ioValue.Cast<  ::flixel::math::FlxMatrix >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *FlxBitmapDataUtil_obj_sMemberStorageInfo = 0;
static hx::StaticInfo FlxBitmapDataUtil_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::flixel::math::FlxMatrix*/ ,(void *) &FlxBitmapDataUtil_obj::matrix,HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void FlxBitmapDataUtil_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxBitmapDataUtil_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(FlxBitmapDataUtil_obj::matrix,"matrix");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxBitmapDataUtil_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxBitmapDataUtil_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(FlxBitmapDataUtil_obj::matrix,"matrix");
};

#endif

hx::Class FlxBitmapDataUtil_obj::__mClass;

static ::String FlxBitmapDataUtil_obj_sStaticFields[] = {
	HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb"),
	HX_HCSTRING("merge","\xb8","\xa2","\xc6","\x05"),
	HX_HCSTRING("mergeColorComponent","\xb2","\x23","\x8f","\xc5"),
	HX_HCSTRING("compare","\xa5","\x18","\x69","\x83"),
	HX_HCSTRING("getDiff","\xbb","\x0b","\xec","\x14"),
	HX_HCSTRING("getMemorySize","\x98","\x08","\x07","\x4f"),
	HX_HCSTRING("replaceColor","\x8f","\x5c","\xeb","\x3d"),
	HX_HCSTRING("addSpacesAndBorders","\x7e","\x17","\x0f","\x63"),
	HX_HCSTRING("copyBorderPixels","\x8e","\x6c","\x7f","\x76"),
	HX_HCSTRING("generateRotations","\x80","\xcb","\xc6","\x62"),
	::String(null())
};

void FlxBitmapDataUtil_obj::__register()
{
	hx::Object *dummy = new FlxBitmapDataUtil_obj;
	FlxBitmapDataUtil_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.util.FlxBitmapDataUtil","\xb3","\x4e","\x39","\xe9");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxBitmapDataUtil_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxBitmapDataUtil_obj::__SetStatic;
	__mClass->mMarkFunc = FlxBitmapDataUtil_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxBitmapDataUtil_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< FlxBitmapDataUtil_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxBitmapDataUtil_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxBitmapDataUtil_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxBitmapDataUtil_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxBitmapDataUtil_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_17_boot)
HXDLIN(  17)		matrix =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
            	}
}

} // end namespace flixel
} // end namespace util
